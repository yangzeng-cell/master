```
1.margin-left的值如果是百分比时，相对于他的包含块的宽度的百分比，即他的父元素

2.性能优化点：link ref=`dns-prefetch`dns预获取，在资源加载之前获取到真实的ip地址

3.rgb R红 G绿 B蓝  \#ff0000 十六进制表示法  rgb(0，0，0) 十进制表示

4.image/vedio是行内可替换元素，不是行内块级元素

5.line-hight是继承属性

6.#表示多个属性是以逗号分隔

7.+表示多个属性是以空格分隔

8.text-align 时将行内元素相对于父级块元素进行居中例如img 文本 input等

9.text-ident和width以em为单位的时候是相对于自身的，font-size可以从父元素继承，如果父元素设置了font-size则会继承下来并相对于自身

10.普遍兄弟选择器只能选中下面的所有兄弟元素

11.script标签放到html的头部时要加window.onload

12.伪类hover,link,visited,active的执行顺序 LVHA

13.除了a标签，hover和active也可以用在其他元素上

14.a元素没有设置伪类，默认所有伪类都是相同的设置

15.::first-line选中首行元素
::first-letter选中首字母
元素之间的间隙默认是换行符，去掉换行符可以

::after{
content:url("./image/icon.svg");//可以这样来添加图片
color:green
}


<p>这是上面代码的实现<br />
  我们有一些 <span data-descr="collection of words and punctuation">文字</span> 有一些
  <span data-descr="small popups which also hide again">提示</span>。<br />
  把鼠标放上去<span data-descr="not to be taken literally">看看</span>。
</p>
//自定义属性
::after伪元素，attr()CSS表达式和一个自定义数据属性 data-descr 创建一个纯CSS
 content: attr(data-descr);
 
 
 16.怎么画0.5px的线
 17.常见的继承属性：font-size,font-weight,font-family,line-height,color,text-align一般和文本有关的
 
18. css的权重
 important 10000
 内联选择器 1000
 id选择器 100
 类选择器，属性选择器，伪类 10
 元素选择器，伪元素 1
 通配选择器  0
19.img，vedio,input是行内替换元素  和其他行内元素在一行显示，可以设置宽高
	行内非替换元素不可以设置宽高
20.伪元素是行内非替换元素，不可以设置宽高，必须转成行内块级元素和块级元素，在使用伪元素过程中必须加content
21.不要在p元素里面放块元素
22.行内元素不要放块级元素，只能放行内元素
23.设置元素不可见的方式
	1.display:none 不占据任何空间
	2.visibility:hidden占据空间不可见
	3.设置颜色透明度
	4.background:transparent可以是背景颜色透明
	5.opacity:1,可以设置透明度，但是会使子元素也会变透明，具有穿透性
24.padding:10px 20px 30px 写三个值得时候，左边没有值，用右边的替代
25.border-radius百分比圆角水平方向是width+border的百分比，圆角垂直方向是height+border的百分比
	border-radius:50%是个圆，超过百分之50%也是圆，超过50%，无效
26.margin
	margin的传递 左右margin不传递
	margin-top的传递 如果块级元素顶部线和父元素的顶部线重叠，那么这个块级元素的margin-top就会传递给父元素
	margin-bottom
	如果块级元素的底部线和父元素的底部线出现重叠，且父元素高度为auto时，会传递
	解决：1.父元素设置border
		 2.父元素使用padding
		 3.触发bfc
	上下margin的折叠 
	兄弟块元素上下两个margin合并成一个margin，折叠后取较大的值。解决方法只设置一个
	父子之间折叠，也会出线相同的情况
27.outline  外轮廓不占据空间，默认显示在border外面 outlone:none		可以去除a元素，input元素focus状态下的默认外轮廓	
28.box-shadow:offset-x offset-y blur(模糊度) 向外扩散的值 color ，多个阴影以逗号分隔，会叠加
29.text-shadow:文字添加阴影
27.行内非替换元素的注意事项
	1.不可以设置width和height
	2.设置margin-top.margin-bottom不生效，margi-left和margin-right生效
	3.设置padding-top,padding-bottom会不等高，且不占据空间，设置padding-right和padding-left生效
	4.设置border和padding给相同效果
28.html5语义化标签
	<header>
	<nav>
	<section>
	<artical>
	<aside>
	<footer>
29.vedio和audio时行内替换元素
   在针对不同的播放格式写法
   <vedio src="">
   		<source src=".../....mp4"></source>
   		<source src=".avi"></source>
   		<source src=""></source>
   		<p>该浏览器不支持</p>
   </vedio>
30.data-*自定义属性，可以html和js中进行数据传递
31.white-space:normal|nowrap|pre|.....
32.text-overflow:clip|esclip text-overflow必须在overflow不是visible才生效
33.css函数
	1.var 定义CSS变量
		属性名要以--开头
		html{
			--main-color:#fffff
		}
		div{
			color:var(--main-color)
		}
	2.calc 计算CSS值，
	3.blur  高斯模糊--毛玻璃效果  blur(radius)可以应用于图片或者元素，radius模糊半径
			可以和filter一起使用。filter:blur(5px)，会使所有子元素都有高斯模糊
			图片的高斯模糊也可以在图片上添加一个遮盖层，用定位元素
			父元素：position:relative
			.cover{
				position:absolute
				top:0
				left:0
				right:0
				bottom:0
				background:rgba(0,0,0,.5)//透明效果
				background-filter:blur(5px)//高斯模糊
			}
	4.gradient 颜色渐变函数 是一种<image>css数据类型的子类型，用于图片颜色的过度转变
	  liner-gradient 线性渐变 background-image:linear-gradient(to right top ,red,blue)     
34.background背景色对也border,padding有效
   color前景色对border也是有效的，border没有设置颜色时，会使用color的值
  35.浏览器前缀：-o-,-xv-,-ms-,-mso-,0moz-.-webkit-
36.bfc 兄弟块元素margin折叠
35.媒体查询
36.css单位
	em 
	rem
	px
	vw/vh
	%
37.less
	定义变量 @mainColor:#ffff
	使用变量 @mainColor
	兼容css
	
	&:hover &::after
	less的运算
	less的混合(Mixins)
	    .box2(@borderwidth:1px,@borderColor:red){
	    	border:@borderwidth solid @borderColor
	    }
	    .box-size{
	    	width:100px;
	    	height:200px
	    }
		.box{
		//混入方式,可以传参
			.box2(2px,green)
			width:.box-size[width]//混入和映射结合使用
			&:extend(.box-size) //继承
		}
		
	less内置函数
		.box{
			color:color(red)//将转换成16进制
			width:convert(100px,"in")单位准换，转成英寸
			floor()向下取整
			ceil()向上取整
		}
	less的作用域：查找一个变量时，会在本地和混入先查找，然后再父级查找
	less的注释
	less的导入 import
	
38.移动端适配
   视口viewport
   	布局视口
   	视觉视口
   	理想视口
   	<meta name="viewport" content="width=980px">//修改布局视口的宽度，对pc端无效
   	<meta name="viewport" content="device-width，initial-scal=1.0,user-scalable=no
   	minimun-scal=1.0,maximun-scale=1.0
   	>
39.	css的相对单位em,是相对于自身的font-size来进行定位的，如果自己已经定义了font-size的px，则用自身的font-size,否则就继承自父元素的font-size
	rem是基于根元素的字体的大小
	vw是视窗宽度的1%
	vh是视窗高度的1%
40.再pc端，布局视口和视觉视口是同一个，不用区分
	默认情况下，一个在PC端的网页在移动端会如何显示呢？
 第一，它会按照宽度为980px来布局一个页面的盒子和内容；
 第二，为了显示可以完整的显示在页面中，对整个页面进行缩小
我们相对于980px布局的这个视口，称之为布局视口（layout 
viewport）；
 布局视口的默认宽度是980px；
	视觉视口（visual viewport）
 如果默认情况下，我们按照980px显示内容，那么右侧有一部分区域
就会无法显示，所以手机端浏览器会默认对页面进行缩放以显示到用
户的可见区域中；
 那么显示在可见区域的这个视口，就是视觉视口（visual viewport）
41.适配方案 – rem+动态html的font-size
   使用该方案有两个问题
   	 问题一：针对不同的屏幕，设置html不同的font-size；
     问题二：将原来要设置的尺寸，转化成rem单位；
    方案一：媒体查询
     可以通过媒体查询来设置不同尺寸范围内的屏幕html的font-size尺寸；
     缺点：
    ✓ 1.我们需要针对不同的屏幕编写大量的媒体查询；
    ✓ 2.如果动态改变尺寸，不会实时的进行更新；
    ◼ 方案二：编写js代码
     如果希望实时改变屏幕尺寸时，font-size也可以实时更改，可以通过js代码；
     方法：
    ✓ 1.根据html的宽度计算出font-size的大小，并且设置到html上；
    ✓ 2.监听页面的实时改变，并且重新设置font-size的大小到html上；
    
    rem的单位换算
	方案一：手动换算
	方案二：less/scss函数
	◼ 方案四：VSCode插件
	 px to rem 的插件，在编写时自动转化
	◼ 方案四：VSCode插件
	 px to rem 的插件，在编写时自动转化三：postcss-pxtorem
	
42。meta标签的作用
	可以在head中定义元信息，例如 比如标题title、样式style、link外部资源等；
     meta用于定义那些不能使用其他定元相关（meta-related）元素定义的任何元数据信息；
    	meta 元素定义的元数据的类型包括以下几种：
             如果设置了 charset 属性，meta 元素是一个字符集声明，告诉文档使用哪种字符编码。
             如果设置了 http-equiv 属性，meta 元素则是编译指令。
             如果设置了 name 属性，meta 元素提供的是文档级别（document-level）的元数据，应用于整个页面。
            	例如：robots，author，Copyright，description，keywords
            	
 43.link图标
 	<link rel="icon" href="https:;;;;" />
 	也可以直接将该favicon.ico直接置于根目录下，不需要使用link来引入，因为大部分浏览器都可以识别
 	
 	
 44.CSS样式的字符编码
 	开发中推荐在CSS的开头编写@charset指定编码：@import "utf-8"
 45.全局属性data-*
 	data设置的属性可以在JavaScript的DOM操作中通过dataset轻松获取到；
	通常用于HTML和JavaScript数据之间的传递；
46.""==null //false
	null和undefined不能转换成任何数据类型进行比较
	
47.const obj={
	[Symbol.toPrimitive](){
	return "123"
	}
}

48.转换成boolean的方式
	Boolean(a)
	!!a
49.switch case 是严格匹配===，还要防止case穿透

50.npx
npx 是 npm v5.2.0 引入的一条命令（ npx ），是一个 npm 包执行器。我们可以使用 npx 来执行各种命令。

主要有以下特点：

临时安装可执行依赖包，不用全局安装，不用担心长期的污染。

可以执行依赖包中的命令，安装完成自动运行。

自动加载 node_modules 中依赖包，不用指定 $PATH 。

可以指定 node 版本、命令的版本，解决了不同项目使用不同

npx 执行流程如下：

到 node_modules/.bin 路径检查对应的命令是否存在，找到之后执行；

没有找到，就去环境变量 $PATH 里面，检查对应命令是否存在，找到之后执行;

还是没有找到，自动下载一个临时的依赖包最新版本在一个临时目录，然后再运行命令，运行完之后删除，不污染全局环境。
51.函数默认的返回值是undefined
52.递归
53.斐波那契数列
	function fibonacci(n){
    if(n===1||n===2) return 1
    return fibonacci(n-1)+fibonacci(n-2)
  }
54.立即执行函数
	1.会立即执行
	2.函数有独立的作用域，可以避免外界访问或者修改内部的变量，
	3.可以有参数和返回值
	4.匿名函数多种写法
			(function(){
			
			})()
            // 匿名函数多种写法
            (function (fn) {
              console.log("立即执行函数");
            })();

            // + - ！都可以，但是不要这样用
            +(function foo() {
              console.log("立即执行函数");
            })();
	5.应用：。
		1.解决命名冲突的问题，防止全局变量的命名冲突
		2.const btnRtm1 = document.querySelectorAll(".btn");
for (var i = 0; i < btnRtm.length; i++) {
  var btn = btnRtm[i];
  (function (m) {
    btn.onclick = function () {
      console.log(m);
    };
  })(i);
}
// 打印 4 4 4 4 .....
// 立即执行函数可以解决上述问题还有for循环中有异步代码例如setTimeout，也可以用let解决
// 因为在如下代码中，但执行onclick执行的时候，此时for循环已经执行完，i已经变成btnRtm.length 所以执行代码永远是4 4 4 ，而使用立即执行函数，会每次将i作为参数传入立即执行函数中，尽管i执行完之后已经变成4，但是m存储这0 1 2 3 
const btnRtm = document.querySelectorAll(".btn");
for (var i = 0; i < btnRtm.length; i++) {
  var btn = btnRtm[i];
  (function (m) {
    btn.onclick = function () {
      console.log(m);
    };
  })(i);
}
// 打印 1 2 3 4....
const btnRtm3 = document.querySelectorAll(".btn");
for (let i = 0; i < btnRtm.length; i++) {
  var btn = btnRtm[i];

  btn.onclick = function () {
    console.log(i);
  };
}
// 打印1 2 3 4 .....

55.js代码规范
56.Object的key是字符串
57.Object可以使用delete来删除属性，Object.name/Object["name"]来获取，或者修改属性，obj[name]是计算属性，name是一个变量
58.Object 遍历可以使用forin,或者Object.keys()   
59.栈内存和堆内存
	原始数据类型是在栈内存
	引用类型实在堆内存
60.包装类型，
   当有包装类型的原始数据类型可以调用方法，是因为js引擎会将原始类型转换成包装类调用对应的方法
   123..toString(2)//转换成二进制
   toFixed(2)保留两位小数。是四舍五入
   parseInt===Number.parseInt
  
   String类
   length
   str[0]
   charAt(0)//字符位置
   for
   for...of
   for...in
   字符串是不可变的
   	例如：var str = "name";
		 str[0] = "v";
		 console.log(str);//name
		 
		 var str = str.toUpperCase();
			console.log(str);//这是新的字符串，不是原来的
	str.indexOf(searchString,fromIndex)//返回值是索引值
	str.includes()
	str.startsWidth("1")//是否以1开头
	str.endsWidth()
	str.replace()
	str.slice()
	str.substring()
	str.substr()
	字符串拼接+，cocat()
	trim()
	split()
	replace()替换，是纯函数
61.Array
	splice()//添加，删除，替换
	pop
	push
	shift
	unshift
	arr.length可以获得数组的长度，修改数组的长度，删除数组
	如果arr.length为6
	arr.length=2//可以删除剩余的元素
	arr.length=0可以删除所有元素
	arr.length=8//可以扩容
	
	arr.slice()
	arr.join()
	arr.concat()
	arr.indexOf()
	arr.find(arr.find(callback[, thisArg]) callback(element,index,array) //会返回匹配到的元素，匹配到多个的时候会返回第一个   find 方法不会改变数组
	arr.findIndex( 	)
	//实现find
	Array.prototype.myFind = function (callback, thisArg) {
  for (let i = 0; i < this.length; i++) {
    if (callback.call(thisArg, this[i], i, this)) {
      return this[i];
    }
  }
};
//实现forEach
	Array.prototype.MyForEach = function (callback, thisArg) {
  for (let i = 0; i < this.length; i++) {
    callback.apply(thisArg, [this[i], i, this]);
  }
};
includes()
arr.sort()
// 默认是降序
arr.sort((item1, item2) => {
  return item1.age - item2.age;
});
console.log(arr);
// 升序
arr.sort((item1, item2) => {
  return item2.age - item1.age;
});
console.log(arr);


arr.reverse()

arr.filter()
Array.prototype.myfilter = function (callback, thisArg) {
  let newArr = [];
  for (let i = 0; i < this.length; i++) {
    if (callback.call(thisArg, this[i], i, this)) {
      newArr.push(this[i]);
    }
  }
  return newArr;
};
arr.map()
arr.reduce()

Date类型
new Date()
Date.now()//当前事件的时间戳
date.getTime()//将时间转换成时间戳
date.valueOf()//也是一样
+date//也可以

将字符串转换成时间戳
var dateString = "2020-5-15";
console.log(new Date(dateString).getTime());
console.log(Date.parse(dateString));
==================================================================================
Dom
62.所有节点都继承自EventTarget
63.document对象-可以获得整个网页node节点
	var html=document.documnetElement
	var body=documnet.body
	body,html,body都是documnet的属性
	获取所有节点的导航 var bodyEl=document.body
	获取所有子节点 bodyEl.childNodes  换行符也属于text节点，注释是comment节点
	获取下一个兄弟节点 bodyEl.nextSibling
	前兄第节点 preSibling
```

打印body的子节点

![](C:\Users\10152\Desktop\study\memo\前端系统课笔记\屏幕截图 2022-05-18 100006.png)

![屏幕截图 2022-05-18 100042](C:\Users\10152\Desktop\study\memo\前端系统课笔记\屏幕截图 2022-05-18 100042.png)



```
64.获取子元素
	bodyEl.children
65.获取第一个子节点  bodyEl.firstElementChild    bodyEl.children[0]  
	bodyEl.nextElementSibling
66.Document和Element的关系
   没有关系。document.body,body是他的属性，不是继承类，body:document.querySelectAll("body") ,所以Documnet和Element不是继承的关系，ELment是body的值
67.table和form之间的导航
68.document.getElementById("")
   documnet.querySelector("")
   document.querySlectorAll("")
   document.getElementsByName("")
   document.getElementsByTagName("")
   document.getElementsByClassName("")//这3个是实时的
69.NodeList是类数组对象，但是可以用forEach,可以用Array.from()转换成array
70.节点类型判断
	通过childNodes获取的节点判断节点类型用nodeType属性 1.元素节点 3.文本 8，注释节点
71.nodeName获取节点名称，tagName元素名
72.data用于非元素节点获取数据 innerHTML 获取元素 textContent获取文本
	设置的时候，innerHTML和innerContent都可以设置文本，innerContent设置元素不会被解析为html元素，会当作普通文本
	innerHTML 将会删除所有该元素的后代并以给出的 htmlString 替代
	不是追加
73.outerHTML会获取本身及其子元素
74.常见全局属性 id style title class hidden:相当于设置display:none
	on+事件
75.attribute
	html定义的是标准attribute
	自定义的属性是非标准attribute
		所有attribute都支持的方法
			element.hasAttribute(e)
			element.getAttribure(e)
			element.setAttribute(e)
			element.removeAttribute(e)
			element.attributes->like array
			
			这些对大小写不敏感，而且返回值都是string
76.property
对象中的属性称为property
元素中的属性称为attribute
标准的attribute中在对应的对象模型中都有对用的property
property和attribute会相互影响
使用点语法也可以获得元素的属性
77.className和classList
	classList是可迭代对象
78.style在js中要使用驼峰
	多个样式可以使用style.cssText=""这个不用写驼峰，但是会覆盖，不推荐
78.style的读取getComputedStyle()
79.data-*
80.var el=document.createElement("element")//创建元素
	el.className=""
	el.classList.add("")
	boxel.append(el)//向父元素插入创建的元素，默认是插入最后
	boxel.prepend(el)//添加到父元素的里面的最前面
	boxel.before(el)//添加到元素的前面
	boxel.after(el)//添加到元素后面
	boxel.replacewith(...node|string)//替换元素
	appendChild,insertbefore这些方法比较旧了
81.el.remove()//将自己移除
82.克隆var newEl=el.cloneNode()//默认是不会克隆子节点cloneNode(true)会克隆子节点
83.获取元素的宽高 ele.width ele.height
84.clientWidth:元素content+padding(不包含滚动条)
	clientTop:border-top的宽度。clientLeft
	offsetWidth:元素的完整宽度content+border+padding
	offsetLeft 距离父元素左边的距离 offsetTop
	scrollHeight 元素可滚动的高度
	scrollTop 滚动条滚动的距离
85.window的大小和滚动
   window.outerWidth//
   window.innerWidth//窗口的宽度，不包括调试窗口和工具栏
   document.doeumnetElement.offsetWidth document.doeumnetElement.offsetHeight
   window.scrollX  获取x轴的滚动位置 window.scrollY Y轴的滚动位置  也可以用别名pagexOffset  pageYOffset
   设置滚动的位置 window.scrollBy(x,y)//在原来的位置基础上叠加滚动的位置
   	window.scrollTo(x,y)//滚动到绝对的位置，到了位置不会变
   	window.onscroll//监听滚动
   	
86.事件
	on+event
	ele.addEventListener("event",callback)
87.事件流
	事件冒泡
	事件捕获
	捕获阶段-》目标阶段-》冒泡阶段
88.event常见属性方法
	event.type:事件类型
	event.target:目标元素
	event.currentTarget:绑定事件的元素
	event.offsetX
	event.clientX
	event.pageX
	event.screenX
	target和currentTarget的区别
		target事件发生的对象，currentTarget是事件绑定的对象，如果
		如果绑定事件的元素和触发事件的元素相同时，target===currentTarget
	event.preventDefault()
	event.propagetion()
	
	on+event中普通函数中this指向绑定事件的元素。addEentListener()也是一样
89.EventTarget类
	所有节点，元素都继承自eventtarget，window也是
	eventTarget.removeEventListener(event,callbackName,)
	eventTarget.dispatchEvent()
90.事件委托
91.import * from 是否包含export default
	export {}和export const a ,export const b有区别吗
92.<div id="box"></div>
	box.click()//如果是id，也可以这样写但是不推荐
92.常见的鼠标事件
	onclick //只能接受event作为唯一的参数，且不用再调用的时候写
	oncontextmenu
	onmousedown
	onmouseup
	onmousemove
93.mouseover和mouseenter的区别
	mouseenter和mouseleave
	不支持冒泡
	进入子元素依然属于该元素只会触发子元素的mouseenter，父元素没反应
	mouseover和mouseout
	支持冒泡
94.键盘事件
	onkeydown
	onkeypress
	onkeyup
	
	event.code 
	event.key
95.onfocus和onblur
96.oninput和onchange
99.表单事件 onsubmit onreset
100.onload和DOMContentLoaded
101.onresize
102.定时器
	setTimeout和setInterval是window的方法
103.ontransitioned监听动画的结束后调用
104.tab切换中切换.active的方法
	1.for循环
	2.使用documnet.queryslector(".active")修改
	3.使用在外面进行变量记录
105.BOM浏览器对象模型
106.node:global==lobalThis
	window:window==globalThis
	放到window的属性全局都可访问
	用var申明的全局对象都放到window对像中
	var openWin=window.open("")//打开网址
	window.close()//只能关闭通过open()打开的新的窗口
107.window常见事件
	window.onfocus
	window.onblur
	window.onhashchange
108.location对象属性，用于表示window当前连接url信息
	location.href//完整url
	//url信息
	location.hostname
	location.host
	loaction.protocol
	location.port
	location.pathname
	location.hash
	loacation.search
	//location方法
	loacation.assign()//打开新的网页，是加入历史记录站，可以返回
	location.replace()//替代当前url,不可以返回
	loaction.reload()//重新加载
109.URLSearchParams
	var searchParams=new URLSearchParams(str)
	get("name“)
	append("address","zzzz")
	hae()
	set()
	中文使用encodeURLComponment和decodeURLComponment进行编解码
110.history
//属性
	history,length
	history.state
//修改history
	history.pushState({name:"mike",age:18})
	hsitory.back()
	history.forword()
	history.go(-2)
	replacestate()
111.json
	var item=JSON.stringfy(item)
	var item=JSON.parse(item)
	json的方法还可以实现深拷贝var obj=JSON.parse(JSON.strigfy(obj1))
112.protobuf
113.&gt; &lt;
114.<button onclick="add()">按钮</button>//再元素上事件的写法
115./* 设置图片水平方向和垂直方向上自动居中，随着浏览器大小的变化 */
.img_center{
  position: relative;
  transform: translate(-50%,-%50);
  left: 50%;
  top:50%;
}

```

116.

![](C:\Users\10152\Desktop\study\memo\前端系统课笔记\屏幕截图 2022-05-25 175414.png)

```
117.this的指向
	1.this的指向是由函数调用执行的时候决定的
	2.this的绑定分为：默认绑定：独立函数调用this是指向window,例如fn()
					隐式绑定：对象中this的指向是指向调用的对象，例如obj.fn()
					显示绑定:通过call,apply,bind来进行显示绑定下，this指向绑定的对象
					new的绑定：通过new创建的对象，this会指向新创建的对象
	3.this指向的优先级：new>显示绑定>隐式绑定>默认绑定
	4.箭头函数是没有this,arguments，是由上层函数作用域来决定，一层一层作用域找
		注意：
		var name="mike"
		var obj={
			
			foo(){
				return ()=>{
					console.log(this.name)
				}
			}
		}//this会先去foo中去找，找不到就去全局作用域，对象中没有作用域
		不可以使用显示绑定改变this的指向
	5.显示绑定中如果指向的是一个基本数据类型，如果有包装类型则转换成包装类
	6.setTimeout中的this默认指向window
	7.forEach中this默认指向window，可以通过第二个参数修改
	8.事件绑定中this指向绑定的元素
	9.new不可以和apply和call一起使用
	10.bind的优先级高于call/apply
	11.new的优先级高于bind
	12.间接函数引用：
		1.(obj1.foo==obj2.foo)()这样直接调用，this是默认绑定指向window
		2.(b=person.sauName)()   //window
	13.foo.apply(null)/foo.apply(undefined)指向window
		
	14.箭头函数可以替代var _this=this来替代，可以获得上层作用域
118. Array.prototype.slice 来将一个类似于数组的对象（array-like object）转换成一个真正的数组，Aaary.prototye.slice.apply()/bind()
119.html解析过程中，遇到css文件会下载，但是不会阻止html的解析，但会阻塞render的渲染过程
120.回流和重绘
121.script
	defer js的下载和执行不阻塞Dom tree的构建
	defer代码执行的时候Dom构建完成，defer会在DomContentLoad以后执行
	多个defer顺序执行
	defer推荐放在head中
	defer仅适用于外部脚本，对script的内容会忽略
	
	async 多个async不能保证顺序执行，不会组设Dom渲染。不能保证DOMContentLoaded之前或者之后执行行
	async用于独立脚本，没有外部依赖
122.函数的执行是在函数执行上下文中执行
123.函数的作用域链再函数创建时就确定了。每个执行上下文都有自己的作用域链
```

​	![](C:\Users\10152\Desktop\study\memo\前端系统课笔记\屏幕截图 2022-05-29 114030.png)

当查找变量的时候，函数首先会在local中寻找，找不到再去上层作用作用域寻找，而这个函数的上层作用域是Window

![](C:\Users\10152\Desktop\study\memo\前端系统课笔记\屏幕截图 2022-05-29 120154.png)

124.垃圾回收器

​		1..引用计数

​					当一个对象有一个引用指向它时，那么这个对象的引用就+1

​					当一个对象的引用为0时，这个对象就可以销毁掉

​					这个算法有一个回答的弊端就是会产生循环引用

​		2.标记清除

​		3.标记整理

​		4.分代收集

​		5.增量收集

​		6.闲时收集

```
125.闭包
	1.狭义：函数引用外层函数的自由变量就是闭包。
	2.通过返回一个函数，外部可以通过这个函数访问这个函数所在作用域链的变量，闭包可以突破作用域链
126.GUI的渲染和js的执行是在同一个线程，是互斥的
```

