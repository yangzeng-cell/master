当我们获取到某个Class对象时，实际上就获取到了一个类的类型：

Class cls = String.class; // 获取到String的Class
还可以用实例的getClass()方法获取：

String s = "";
Class cls = s.getClass(); // s是String，因此获取到String的Class
最后一种获取Class的方法是通过Class.forName("")，传入Class的完整类名获取：

Class s = Class.forName("java.lang.String");
这三种方式获取的Class实例都是同一个实例，因为JVM对每个加载的Class只创建一个Class实例来表示它的类型。

获取父类的Class
有了Class实例，我们还可以获取它的父类的Class：

// reflection
public class Main {
    public static void main(String[] args) throws Exception {
        Class i = Integer.class;
        Class n = i.getSuperclass();
        System.out.println(n);
        Class o = n.getSuperclass();
        System.out.println(o);
        System.out.println(o.getSuperclass());
    }
}

 获取interface
由于一个类可能实现一个或多个接口，通过Class我们就可以查询到实现的接口类型。例如，查询Integer实现的接口：

// reflection
import java.lang.reflect.Method;
public class Main {
    public static void main(String[] args) throws Exception {
        Class s = Integer.class;
        Class[] is = s.getInterfaces();
        for (Class i : is) {
            System.out.println(i);
        }
    }
}

 此外，对所有interface的Class调用getSuperclass()返回的是null，获取接口的父接口要用getInterfaces()：

 继承关系
当我们判断一个实例是否是某个类型时，正常情况下，使用instanceof操作符：

Object n = Integer.valueOf(123);
boolean isDouble = n instanceof Double; // false
boolean isInteger = n instanceof Integer; // true
boolean isNumber = n instanceof Number; // true
boolean isSerializable = n instanceof java.io.Serializable; // true
如果是两个Class实例，要判断一个向上转型是否成立，可以调用isAssignableFrom()：

// Integer i = ?
Integer.class.isAssignableFrom(Integer.class); // true，因为Integer可以赋值给Integer
// Number n = ?
Number.class.isAssignableFrom(Integer.class); // true，因为Integer可以赋值给Number
// Object o = ?
Object.class.isAssignableFrom(Integer.class); // true，因为Integer可以赋值给Object
// Integer i = ?
Integer.class.isAssignableFrom(Number.class); // false，因为Number不能赋值给Integer
小结
通过Class对象可以获取继承关系：

Class getSuperclass()：获取父类类型；
Class[] getInterfaces()：获取当前类实现的所有接口。
通过Class对象的isAssignableFrom()方法可以判断一个向上转型是否可以实现