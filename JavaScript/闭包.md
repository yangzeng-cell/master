闭包就是一个函数可以访问另一个函数内部的变量。创建闭包的最常见的方法就是在一个函数内部创建另外一个函数，通过这个函数来访问当前函数的变量，通过闭包可以突破作用域链。可以是变量常驻内存，不会被垃圾回收机制回收。

闭包的主要用途就是在函数外部来访问函数内部的变量。第二个用途就是使已经运行结束的函数上下文的变量继续存在内存中，因为闭包函数保留了该函数地引用。就是函数仍然被其他变量所引用。



闭包产生的本质就是：当前环境中存在指向父级作用域的引用

**闭包的表现形式**

1. 返回一个函数
2. `在定时器、事件监听、Ajax 请求、Web Workers 或者任何异步中，只要使用了回调函数，实际上就是在使用闭包`。请看下面这段代码，这些都是平常开发中用到的形式

```js
// 定时器
setTimeout(function handler(){
  console.log('1');
}，1000);
// 事件监听
$('#app').click(function(){
  console.log('Event Listener');
});
```

1. 作为函数参数传递的形式，比如下面的例子。

```js
var a = 1;
function foo(){
  var a = 2;
  function baz(){
    console.log(a);
  }
  bar(baz);
}
function bar(fn){
  // 这就是闭包
  fn();
}
foo();  // 输出2，而不是1
```

1. `IIFE（立即执行函数），创建了闭包，保存了全局作用域（window）和当前函数的作用域`，因此可以输出全局的变量，如下所示

```js
var a = 2;
(function IIFE(){
  console.log(a);  // 输出2
})();
```

> IIFE 这个函数会稍微有些特殊，算是一种自执行匿名函数，这个匿名函数拥有独立的作用域。这不仅可以避免了外界访问此 IIFE 中的变量，而且又不会污染全局作用域，我们经常能在高级的 JavaScript 编程中看见此类函数。

**如何解决循环输出问题？**

> 在互联网大厂的面试中，解决循环输出问题是比较高频的面试题，一般都会给一段这样的代码让你来解释

```js
for(var i = 1; i <= 5; i ++){
  setTimeout(function() {
    console.log(i)
  }, 0)
}
```

上面这段代码执行之后，从控制台执行的结果可以看出来，结果输出的是 5 个 6，那么一般面试官都会先问为什么都是 6？我想让你实现输出 1、2、3、4、5 的话怎么办呢？

因此结合本讲所学的知识我们来思考一下，应该怎么给面试官一个满意的解释。你可以围绕这两点来回答。

- `setTimeout` 为宏任务，由于 JS 中单线程 `eventLoop 机制`，在主线程同步任务执行完后才去执行宏任务，因此`循环结束后 setTimeout 中的回调才依次执行`
- 因为 `setTimeout` 函数也是一种闭包，往上找它的`父级作用域链就是 window`，`变量 i 为 window 上的全局变量`，开始执行 setTimeout 之前变量 i 已经就是 6 了，因此最后输出的连续就都是 6。

> 那么我们再来看看如何按顺序依次输出 1、2、3、4、5 呢？

1. 利用 IIFE

> 可以利用 IIFE（立即执行函数），当每次 for 循环时，把此时的变量 i 传递到定时器中，然后执行，改造之后的代码如下。

```js
for(var i = 1;i <= 5;i++){
  (function(j){
    setTimeout(function timer(){
      console.log(j)
    }, 0)
  })(i)
}
```

1. 使用 ES6 中的 let

> ES6 中新增的 let 定义变量的方式，使得 ES6 之后 JS 发生革命性的变化，让 JS 有了块级作用域，代码的作用域以块级为单位进行执行。通过改造后的代码，可以实现上面想要的结果。

```js
for(let i = 1; i <= 5; i++){
  setTimeout(function() {
    console.log(i);
  },0)
}
```

1. 定时器传入第三个参数

> setTimeout 作为经常使用的定时器，它是存在第三个参数的，日常工作中我们经常使用的一般是前两个，一个是回调函数，另外一个是时间，而第三个参数用得比较少。那么结合第三个参数，调整完之后的代码如下。

```js
for(var i=1;i<=5;i++){
  setTimeout(function(j) {
    console.log(j)
  }, 0, i)
}
```

从中可以看到，第三个参数的传递，可以改变 setTimeout 的执行逻辑，从而实现我们想要的结果，这也是一种解决循环输出问题的途径