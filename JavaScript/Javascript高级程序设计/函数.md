***`箭头函数不能使用 arguments、super 和 new.target，也不能用作构造函数。此外，箭头函数也没有 prototype 属性。*`**

**ECMAScript 中的所有参数都按值传递的。不可能按引用传递参数。如果把对象作 为参数传递，那么传递的值就是这个对象的引用。**



```
默认参数作用域与暂时性死区
因为在求值默认参数时可以定义对象，也可以动态调用函数，所以函数参数肯定是在某个作用域中
求值的。
给多个参数定义默认值实际上跟使用 let 关键字顺序声明变量一样。来看下面的例子：
function makeKing(name = 'Henry', numerals = 'VIII') { 
 return `King ${name} ${numerals}`; 
} 
console.log(makeKing()); // King Henry VIII 
这里的默认参数会按照定义它们的顺序依次被初始化。可以依照如下示例想象一下这个过程：
function makeKing() { 
 let name = 'Henry'; 
 let numerals = 'VIII'; 
 return `King ${name} ${numerals}`; 
} 
因为参数是按顺序初始化的，所以后定义默认值的参数可以引用先定义的参数。看下面这个例子：
function makeKing(name = 'Henry', numerals = name) { 
 return `King ${name} ${numerals}`; 
} 
console.log(makeKing()); // King Henry Henry	



参数也存在于自己的作用域中，它们不能引用函数体的作用域：
// 调用时不传第二个参数会报错
function makeKing(name = 'Henry', numerals = defaultNumeral) { 
 let defaultNumeral = 'VIII'; 
 return `King ${name} ${numerals}`; 
}
```

rest参数如果有多个参数 ，必须放在参数的后面，否则会报错

```
收集参数的前面如果还有命名参数，则只会收集其余的参数；如果没有则会得到空数组。因为收集
参数的结果可变，所以只能把它作为最后一个参数：
// 不可以
function getProduct(...values, lastValue) {} 
// 可以
function ignoreFirst(firstValue, ...values) { 
 console.log(values); 
} 
ignoreFirst(); // [] 
ignoreFirst(1); // [] 
ignoreFirst(1,2); // [2] 
ignoreFirst(1,2,3); // [2, 3] 

使用收集参数并不影响 arguments 对象，它仍然反映调用时传给函数的参数

function getSum(...values) { 
 console.log(arguments.length); // 3 
 console.log(arguments); // [1, 2, 3] 
 console.log(values); // [1, 2, 3] 
} 
console.log(getSum(1,2,3)); 
```

**函数声明与函数表达式**

函数声明可以在任何地方运行，因为函数是第一公民，JavaScript 引擎在任何代码执行之前，会先读取函数声明，并在执行上下文中 生成函数定义。而函数表达式必须等到代码执行到它那一行，才会在执行上下文中生成函数定义。函数表达式必须先赋值再执行

##### **** new.target****

ECMAScript 中的函数始终可以作为构造函数实例化一个新对象，也可以作为普通函数被调用。 ECMAScript 6 新增了检测函数是否使用 new 关键字调用的 new.target 属性。如果函数是正常调用的，则 new.target 的值是 undefined；如果是使用 new 关键字调用的，则 new.target 将引用被调用的 构造函数。

```
function King() { 
 if (!new.target) { 
 throw 'King must be instantiated using "new"' 
 } 
 console.log('King instantiated using "new"'); 
} 
new King(); // King instantiated using "new" 
King(); // Error: King must be instantiated using "new"
```

##### 每个函数都有prototype和length属性。length 属性保存函数定义的命名参数的个数。prototype 是保存引用类型所有实例 方法的地方，这意味着 toString()、valueOf()等方法实际上都保存在 prototype 上，进而由所有实 例共享。这个属性在自定义类型时特别重要。在 ECMAScript 5 中，prototype 属性是不可枚举的，因此使用 for-in 循环不会返回这个属性。在 ECMAScript 5 中，prototype 属性是不可枚举的，因此使用 for-in 循环不会返回这个属性。

闭包就是引用另外一个函数作用域中变量的函数

```
在闭包中使用 this 会让代码变复杂。如果内部函数没有使用箭头函数定义，则 this 对象会在运
行时绑定到执行函数的上下文。如果在全局函数中调用，则 this 在非严格模式下等于 window，在严
格模式下等于 undefined。如果作为某个对象的方法调用，则 this 等于这个对象。匿名函数在这种情
况下不会绑定到某个对象，这就意味着 this 会指向 window，除非在严格模式下 this 是 undefined。
不过，由于闭包的写法所致，这个事实有时候没有那么容易看出来。来看下面的例子：
window.identity = 'The Window'; 
let object = { 
 identity: 'My Object', 
 getIdentityFunc() { 
 return function() { 
 return this.identity; 
 }; 
 } 
}; 
console.log(object.getIdentityFunc()()); // 'The Window'


这里先创建了一个全局变量 identity，之后又创建一个包含 identity 属性的对象。这个对象还
包含一个 getIdentityFunc()方法，返回一个匿名函数。这个匿名函数返回 this.identity。因为
getIdentityFunc()返回函数，所以 object.getIdentityFunc()()会立即调用这个返回的函数，
从而得到一个字符串。可是，此时返回的字符串是"The Winodw"，即全局变量 identity 的值。为什么匿名函数没有使用其包含作用域（getIdentityFunc()）的 this 对象呢？
前面介绍过，每个函数在被调用时都会自动创建两个特殊变量：this 和 arguments。内部函数永
远不可能直接访问外部函数的这两个变量。但是，如果把 this 保存到闭包可以访问的另一个变量中，
则是行得通的。比如：

window.identity = 'The Window'; 
let object = { 
 identity: 'My Object', 
 getIdentityFunc() { 
 let that = this; 
 return function() { 
 return that.identity; 
 }; 
 } 
}; 
console.log(object.getIdentityFunc()()); // 'My Object' 
这里加粗的代码展示了与前面那个例子的区别。在定义匿名函数之前，先把外部函数的 this 保存
到变量 that 中。然后在定义闭包时，就可以让它访问 that，因为这是包含函数中名称没有任何冲突的
一个变量。即使在外部函数返回之后，that 仍然指向 object，所以调用 object.getIdentityFunc()()
就会返回"My Object"


```

### 注意 this 和 arguments 都是不能直接在内部函数中访问的。如果想访问包含作用域中 的 arguments 对象，则同样需要将其引用先保存到闭包能访问的另一个变量中。





```
在一些特殊情况下，this 值可能并不是我们所期待的值。比如下面这个修改后的例子：
window.identity = 'The Window'; 
let object = { 
 identity: 'My Object', 
 getIdentity () { 
 return this.identity; 
 } 
}; 
getIdentity()方法就是返回 this.identity 的值。以下是几种调用 object.getIdentity()
的方式及返回值：
object.getIdentity(); // 'My Object' 
(object.getIdentity)(); // 'My Object' 
(object.getIdentity = object.getIdentity)(); // 'The Window' 
第一行调用 object.getIdentity()是正常调用，会返回"My Object"，因为 this.identity
就是 object.identity。第二行在调用时把 object.getIdentity 放在了括号里。虽然加了括号之
后看起来是对一个函数的引用，但 this 值并没有变。这是因为按照规范，object.getIdentity 和
(object.getIdentity)是相等的。第三行执行了一次赋值，然后再调用赋值后的结果。因为赋值表
达式的值是函数本身，this 值不再与任何对象绑定，所以返回的是"The Window"。
一般情况下，不大可能像第二行和第三行这样调用对象上的方法。但通过这个例子，我们可以知道，
即使语法稍有不同，也可能影响 this 的值。

```





##### 立即调用的函数表达式

```
(function() { 
 // 块级作用域 
})(); 
使用 IIFE 可以模拟块级作用域，即在一个函数表达式内部声明变量，然后立即调用这个函数。这
样位于函数体作用域的变量就像是在块级作用域中一样。ECMAScript 5 尚未支持块级作用域，使用 IIFE
模拟块级作用域是相当普遍的。比如下面的例子：
// IIFE 
(function () { 
 for (var i = 0; i < count; i++) { 
 console.log(i); 
 } 
})(); 


/ 内嵌块级作用域 
{ 
 let i; 
 for (i = 0; i < count; i++) { 
 console.log(i); 
 } 
} 
console.log(i); // 抛出错误
// 循环的块级作用域
for (let i = 0; i < count; i++) { 
 console.log(i); 
} 
console.log(i); // 抛出错误
```

